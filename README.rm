Database structures.

Условия на проектите Homework one - Homework five от "SD semester projects mostly":
	
	Домашно #1
		Напишете програма която приема за вход инфиксен израз и файл който описва операторите използвани в изараза и извежда резултата след пресмятане на израза. В израза ще има числа, знаци (оператори) и скоби, като скобите винаги са с най-висок приоритет. Операторите в израза са символи които имат определен приоритет и асоциативност описани във входния фаил в следния формат:

		символ оператор приоритет аосциативност
		асоциативност: 1 = дясно, 0 = ляво
		приоритет: по-голям приоритет = изпълнява се преди тези с по-малък
		операторите са тези: +-*/
		символът ще бъде операцията в израза

		Пример за файла:
			a + 10 1
			b + 5 1
			c - 5 1
			d * 10 1
			e / 10 0
			f / 10 1
		Пример за израз:
			31 a ( 5 b 32 f 10 e -230 ) c 324 d 17
		Допълнителни забележки:
		Структурите от данни трябва да са с ваши имплементации или да разбирате в дълбочина използваните.
		Името на файла и израза ще се подават като аргументи на командият ред на вашата програма.
		Файлът с правилата за операторите ще бъде винаги валиден, но изразът ще трябва вие да го валидирате и да изведете съобщение за грешка ако не е валиден.
		Ако има отрицателни числа в израза то знакът минус '-' ще бъде долепен до числото, ако не е долепен то значи този знак трябва да се намира във файлът или израза е невалиден.

	Домашно #2 (списък, опашка)
		Имайки следното:
		class Market 
		{
		public:
		    Market(int NumberOfAllCashDecks); // максимални брой каси които може да бъдат отворени в магазина (без експресната)
		    void AddClient(Client * clients, int number); // добавяме number клиенти в магазина
		    MarketState getMarketState(); // връща състоянието на магазина
		    ClientState getClientState(int ID); // връща състоянието на клиента
		};

		struct ClientState
		{
		    int CashDeskPosition; // номер на каса
		    int QueuePosition; // позиция в опашката на касата
		    Client * client;
		};

		struct MarketState
		{
		    int numberOfCashDesk; // броя на касите които са отворили в момента
		    int * numberOfClientsAtCashDecsk; // броя на клиентите на всяка каса в този момент
		    int numberOfClientsAtExpressCashDeck;
		};

		struct Client
		{
		    int ID; // уникален номер на клиента в магазина
		    int numberOfGoods; // брой на покупките на клиента
		    bool creditCard; // истина ако плаща с крединта карта
		};
		Решете следният проблем:

		Имаме магазин с N каси и допълнително една експресна. На всеки "tick" на магазина всички каси обработват по един продукт от кошницата на клиентите клиентите си намират места на касите и може да се случи едно от следните действия(действията се случват в този ред ):

		1. Затваряне на каса
		2. Преместване на клиенти
		3. Отваряне на каса
		** като техния приоритет е както следва  1 > 2 > 3
		Забележка ако има предпоставки за случването на повече от едно действие то се случва само това с най-голям приоритет. Ако има няколко места в магазина където може да се случи едно и също деиствие и то е с най-висок приоритет то се случва само на касата която е с "по-малък пореден номер" (тоест по напред в листа)

		Действията се случват на следният принцип: На всеки "tick" се проверява по колко души има на опашка на всяка каса и ако на някоя каса има повече от N клиента се отваря нова каса и се разделя опашката на две равни части (през средата). Ако има каси чиято разлика е повече от N/8 клента то половината от клиентите на по-дългата опашка трябва да си намерят по удачно място (тоест да се пренаредят по останалите опашки). Ако някоя каса има по малко от N/10 клиента алчния мениджър я затваря и хората трябва да се преразпределят по останалите каси. Когато дойде нов клиент на касите той се нарежда на опашката с най-малко хора или ако с с равен на тази с по-малък пореден номер. Ако клиента има 3 или по-малко продукта и на експресната каса има по-малко от 2*Nто той се нарежда на нея.

		Уточнение експресната каса никога не затваря както и никога не преразпределя клиентите си(тоест не подлежи на никое от горните 3 правила).

		Клиентите идват на всеки "tick" но понеже магазина е доста натоварен то част от тях минават през касите без да са си купили нищо за тях (имат нула продукта и минават директно). Хората които плащат с кредитна карта им отнема 1 "tick" да платят (след като всички продукти са били обработени) а на хората плащащи в брой им отнема 2 "tick"-а.

		При инициализиране на вашия клас ще получите с колко каси разполага магазина. Като в началото задължително ще работи 1 нормална каса + експресната. Чрез методите getClientState и getМаrketState ще искаме да можем да следим текущото състояние на магазина като информация за клента ще получаваме като го търсим по ID-то му което ще получава на входа на магазина (метода Add). При всяко извикване на метода addто в магазина минава един "tick", тоест се правят нужните пренареждания и касите извършват едно действие.

		Изисквания към имплементацията : От вас се изисква да предоставите като публичен интерфейс само функциите които сме ви дали в класа Market (със същите имена на функциите и променливите). Останалата част от имплементацията е изцяло по ваше усмотрение. Също така е задължително да имате списък от опашки който да представлява множеството от каси с чакащите хора на тях .Списъкът и опашката трябва да са имплементирани от вас като не се позволява използването на кой да е контейнер от STL. Може да ползвате други имплементирани контейнери от вас ако сметнете за добре.
	
	Домашно #3
		Направете 5 класа които имплементират Sorter интерфейс и имплементират поне 5 различни алгоритъма за сортиране, като 4 от тях са (heap, merge, quick, insertion).

		template<typename T>
		class Sorter {
		public:
			virtual void sort(T * data, size_t count) = 0;
			virtual unsigned long long getSortTime() const = 0;
		};
		Направете клас, имплементиращ SortTester, който да изпълни сортиращата функция на всеки от класовете подадени в конструктора му. Сортирането се извършва върху данни, които самият SortTester трябва да генерира. Методът getSummary трябва да извежда кратка статистика за изпълнението на сортиращите алгоритми включваща времето за което се изпълняват и описание на данните върху които са работили.

		template<typename T>
		class SortTester {
		public:
			SortTester(Sorter<T> ** sorters, int count) {}
			virtual void getSummary(std::ostream & out) = 0;
		};
		Към домашното си качете кратко описание на данните, които вашият тестов клас генерира. Опишете как се справят алгоритмите, които сте имплементирали с генерираните от вас данни. Добавете и изхода отSortTester::getSummary.

	Домашно #4
		Напишете програма която ви позволява да създавате XML документи. Трябва да измислите и направите удобен интерфейс (клас/класове) за създаване на документа и добавяне/премахване/променяне на елемнтите в него. Трябва като минимум да имплементирате следната функционалност:

		Добавяне/Изтриване/Променяне на тагове
		Добавяне/Изтриване/Променяне на атрибути на таг
		Итериране на елементите йерархично
		Изпринтиране на документа в изходен поток по два начина - добре форматирано и сбито (без излишни нови редове и разстояние)
		Забележки:

		Нужно е да се поддържат само ASCII символи
		Достъпа и промяната на елемент става с низ с неговия пълен път в документа, например: "root/person/name". Ако има повече от 1 елемнт, отговарящ на пътя, то тогава се променят всички.
		Използвайте адекватни структури и контейнери за вашите данни, като се грижите за правилното използване на паметта ако ползвате собствени имплементации. Ако не, трябва да разбирате имплементацията която използвате!
		<root>
		  <person>
		    <name>One</name>
		    <name>Something</name>
		    <email/>
		  </person>
		  <person>
		    <name>Two</name>
		    <email>example@example.com</email>
		  </person>
		</root>

	Домашно #5
		Хората от гражданска защита искат да си свършат работата добросъвестно и за това искат да знаят къде биха възникнали проблеми при евентуални продължителни валежи в град Чирбод за да могат да предприемат необходимите мерки за отводняването на града в случай на бедствие.
		Тези хора са ви помолили да им помогнете с проблема като съставите програма, която прави симулации. Вашата задача е изключително отговорна и може да спаси домовете на хората.
		След дълги дискусии те са успели да формулират заданието си по подходящ за един програмист начин.
		Град Чирбод има правоъгълна форма. Всички улици минават успоредно на страните на правоъгълника на еднакво разстояние една от друга и от край до край на града. Номерирани са от запад на изток от 0 до M-1и от север на юг от 0 до N-1, където M и N са естествени числа, всяко по-малко от 1000. Всеки две улици които се пресичат в рамките на града образуват кръстовище, номерирано с двата индекса на улиците. Имате карта на която са нанесени височините на кръстовищата - цели числа в интервала [-100, 1000]. Тя представлява матрица NxM. В града всички улици имат еднаква ширина което означава че и еднакво количество вода може да минава през тях за единица време. Нека обозначим това количество с C.
		От вас се иска при наличието на карта на височината на кръстовищата в града и пропускателната възможност на улиците да напишете програма, която симулира оттичането на водата за определено време при падането на дадено количество валежи X във всеки район от града (тоест на всяко кръстовище изливат по X литра вода). Водата тече винаги от високо към ниско (тоест строго >). Като съответно ако има 2 или повече възможни места който са по ниски от текущото, равни количества вода поемат във всички възможни посоки. Кръстовищата който са в края на града имат пропускателна способност навън 2*C към всяка граница с която граничат и приемаме че в съседство на града има по-ниско разположена река която може да поеме неограничено количество вода. Водата тече само по улиците в хоризонтална и вертикална посока, но не тече по диагонал.
		На входа на програмата получавате на първия редчислата M, N и C. Последвани от MxN числа представляващи картата с височините. След това получавате число S последвано от S двойки числа К и Т. K означава литрите който ще паднат на всяко поле е Т е времето което искаме да продължи нашата симулация.
		На изхода искаме да получим S матрици от числа MxN означаващи количеството вода което е останало на кръстовищата след време Т. Ако Т е много голямо число вашата програма трябва да може да осъзнае момента, в който симулацията достига стабилно състояние и няма смисъл да продължава, защото няма как да доведе до ново състояние и трябва да изведете резултата който сте получили в този момент.

